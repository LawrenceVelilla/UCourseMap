"use client"

import { useQuery, useQueryClient } from "@tanstack/react-query"
import { useEffect, useMemo } from "react"
import useDebounce from "./useDebounce"

interface SearchResult {
  id: string
  department: string
  courseCode: string
  title: string
}

// Cache search results in memory (browser only)
const localCache = new Map<string, { data: SearchResult[]; timestamp: number }>()
const LOCAL_CACHE_TTL = 5 * 60 * 1000 // 5 minutes

export function usePrefixSearch(query: string, debounceMs = 300) {
  const debouncedQuery = useDebounce(query, debounceMs)
  const queryClient = useQueryClient()

  // Extract prefix (first 2 characters) for prefetching
  const prefix = useMemo(() => {
    const cleaned = query.trim().toUpperCase()
    return cleaned.length >= 2 ? cleaned.substring(0, 2) : null
  }, [query])

  // Main query - uses the full debounced query
  const {
    data: results = [],
    isLoading,
    isFetching,
    isError,
    error,
  } = useQuery<SearchResult[]>({
    queryKey: ["courses", debouncedQuery],
    queryFn: async () => {
      // Check local cache first (browser memory, not Redis)
      const cacheKey = `query:${debouncedQuery}`
      const cached = localCache.get(cacheKey)
      const now = Date.now()

      if (cached && now - cached.timestamp < LOCAL_CACHE_TTL) {
        return cached.data
      }

      // If not in local cache, fetch from API
      const data = await fetchCourses(debouncedQuery)

      // Store in local cache
      localCache.set(cacheKey, { data, timestamp: now })

      // Clean up old cache entries
      for (const [key, value] of localCache.entries()) {
        if (now - value.timestamp > LOCAL_CACHE_TTL) {
          localCache.delete(key)
        }
      }

      return data
    },
    enabled: debouncedQuery.length >= 2,
    staleTime: 5 * 60 * 1000, // Consider results fresh for 5 minutes
    gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes
  })

  // Prefetch prefix data when we have a valid prefix
  useEffect(() => {
    if (prefix && prefix.length >= 2) {
      // Only prefetch for common prefixes to save Redis usage
      const commonPrefixes = ["CM", "CS", "MA", "PH", "BI", "EN", "CH"]
      if (commonPrefixes.includes(prefix)) {
        queryClient.prefetchQuery({
          queryKey: ["courses-prefix", prefix],
          queryFn: () => fetchCoursesByPrefix(prefix),
          staleTime: 5 * 60 * 1000,
        })
      }
    }
  }, [prefix, queryClient])

  return {
    results,
    isLoading,
    isFetching,
    isError,
    error,
  }
}

// Fetch courses with the full query
async function fetchCourses(q: string): Promise<SearchResult[]> {
  if (q.length < 2) return []
  const res = await fetch(`/api/courses/search?q=${encodeURIComponent(q)}`)
  if (!res.ok) throw new Error((await res.json()).error || res.statusText)
  return res.json()
}

// Fetch courses by prefix (could be a different endpoint optimized for prefix searches)
async function fetchCoursesByPrefix(prefix: string): Promise<SearchResult[]> {
  const res = await fetch(`/api/courses/prefix?prefix=${encodeURIComponent(prefix)}`)
  if (!res.ok) throw new Error((await res.json()).error || res.statusText)
  return res.json()
}
