import { type NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/data"
import { z } from "zod"
import { Ratelimit } from "@upstash/ratelimit"
import { Redis } from "@upstash/redis"
import { ipAddress } from "@vercel/edge"

// Set up Redis + rate limiter
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})
const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, "10 s"),
  analytics: true,
})

// Validate `prefix` param
const PrefixQuerySchema = z.object({
  prefix: z.string().min(1).max(5),
})

// Track popular prefixes to optimize caching
const POPULAR_PREFIXES = ["CM", "CS", "MA", "PH", "BI", "EN", "CH"]

export async function GET(request: NextRequest) {
  // rateâ€‘limit by IP
  const ip = ipAddress(request) || "127.0.0.1"
  const { success } = await ratelimit.limit(ip)
  if (!success) {
    return new NextResponse("Too Many Requests", { status: 429 })
  }

  // parse + validate
  const prefix = request.nextUrl.searchParams.get("prefix") ?? ""
  const parse = PrefixQuerySchema.safeParse({ prefix })
  if (!parse.success) {
    return NextResponse.json({ error: 'Missing or invalid "prefix" parameter.' }, { status: 400 })
  }

  const term = parse.data.prefix.trim().toUpperCase()

  try {
    // Only use Redis for popular prefixes to save on Redis usage
    if (POPULAR_PREFIXES.includes(term)) {
      // Try to get from Redis cache first
      const cachedData = await redis.get(`prefix:${term}`)
      if (cachedData) {
        return NextResponse.json(JSON.parse(cachedData as string))
      }
    }

    // If not in cache or not a popular prefix, query the database
    const courses = await prisma.course.findMany({
      where: {
        OR: [
          { courseCode: { startsWith: term, mode: "insensitive" } },
          { department: { startsWith: term, mode: "insensitive" } },
        ],
      },
      select: { id: true, department: true, courseCode: true, title: true },
      take: 50, // Limit results to save bandwidth
      orderBy: [{ courseCode: "asc" }],
    })

    // Only cache popular prefixes to save Redis storage
    if (POPULAR_PREFIXES.includes(term)) {
      await redis.set(`prefix:${term}`, JSON.stringify(courses), {
        ex: 3600, // Cache for 1 hour
      })
    }

    return NextResponse.json(courses)
  } catch (err) {
    console.error(err)
    return NextResponse.json({ error: "Internal server error." }, { status: 500 })
  }
}
