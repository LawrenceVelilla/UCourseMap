import { type NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/data"
import { z } from "zod"
import { Ratelimit } from "@upstash/ratelimit"
import { Redis } from "@upstash/redis"
import { ipAddress } from "@vercel/edge"

// Set up Redis + rate limiter
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})
const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, "10 s"),
  analytics: true,
})

// Validate `q` param
const SearchQuerySchema = z.object({
  q: z.string().min(1, "Search query cannot be empty."),
})

// Track search frequency to identify popular searches
const SEARCH_FREQUENCY_TTL = 86400 // 24 hours in seconds

export async function GET(request: NextRequest) {
  // rateâ€‘limit by IP
  const ip = ipAddress(request) || "127.0.0.1"
  const { success } = await ratelimit.limit(ip)
  if (!success) {
    return new NextResponse("Too Many Requests", { status: 429 })
  }

  // parse + validate
  const q = request.nextUrl.searchParams.get("q") ?? ""
  const parse = SearchQuerySchema.safeParse({ q })
  if (!parse.success) {
    return NextResponse.json({ error: 'Missing or invalid "q" parameter.' }, { status: 400 })
  }

  const term = parse.data.q.trim().toUpperCase()

  try {
    // Only check cache for queries longer than 3 characters
    // This reduces Redis usage for very short queries
    let courses
    if (term.length > 3) {
      // Try to get from cache first
      const cacheKey = `search:${term}`
      const cachedData = await redis.get(cacheKey)

      if (cachedData) {
        // Track this search to identify popular searches
        await redis.incr(`freq:${term}`)
        return NextResponse.json(JSON.parse(cachedData as string))
      }

      // If not in cache, query the database
      courses = await prisma.course.findMany({
        where: {
          OR: [
            { courseCode: { contains: term, mode: "insensitive" } },
            { title: { contains: term, mode: "insensitive" } },
          ],
        },
        select: { id: true, department: true, courseCode: true, title: true },
        take: 10,
        orderBy: [{ courseCode: "asc" }],
      })

      // Track search frequency
      const frequency = await redis.incr(`freq:${term}`)
      await redis.expire(`freq:${term}`, SEARCH_FREQUENCY_TTL)

      // Only cache if this search has been done multiple times
      // This prevents filling Redis with one-off searches
      if (frequency > 2) {
        await redis.set(cacheKey, JSON.stringify(courses), {
          ex: 1800, // Cache for 30 minutes
        })
      }
    } else {
      // For very short queries, just query the database directly
      courses = await prisma.course.findMany({
        where: {
          OR: [
            { courseCode: { contains: term, mode: "insensitive" } },
            { title: { contains: term, mode: "insensitive" } },
          ],
        },
        select: { id: true, department: true, courseCode: true, title: true },
        take: 10,
        orderBy: [{ courseCode: "asc" }],
      })
    }

    return NextResponse.json(courses)
  } catch (err) {
    console.error(err)
    return NextResponse.json({ error: "Internal server error." }, { status: 500 })
  }
}
